#!/usr/bin/env python3
import boto3, sys, os, requests, json, wget, urllib3
from datetime import datetime
from hurry.filesize import size
from colorama import Fore
import subprocess
from urllib.parse import quote
from dateutil import parser

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
date_message = ''

sub_path = sys.argv[1]
webinar_id = sys.argv[2]

if sys.argv[3] == 'Z1':
    account_id = os.environ.get('Z1_AI')
    client_id = os.environ.get('Z1_CI')
    client_secret = os.environ.get('Z1_CS')
elif sys.argv[3] == 'Z2':
    account_id = os.environ.get('Z2_AI')
    client_id = os.environ.get('Z2_CI')
    client_secret = os.environ.get('Z2_CS')
elif sys.argv[3] == 'Z3':
    account_id = os.environ.get('Z3_AI')
    client_id = os.environ.get('Z3_CI')
    client_secret = os.environ.get('Z3_CS')
elif sys.argv[3] == 'Z4':
    account_id = os.environ.get('Z4_AI')
    client_id = os.environ.get('Z4_CI')
    client_secret = os.environ.get('Z4_CS')

try:
    raw_date = sys.argv[4]
    current_date = parser.parse(raw_date)
except IndexError:
    current_date = datetime.now()
    date_message = "today's"
except ValueError:
    print(f"{Fore.RED}Invalid date format. Use formats like 20250519, 2025-05-19 or 19-05-2025.{Fore.RESET}")
    sys.exit(1)

formatted_date = current_date.strftime("%Y%m%d")
date_message = f"{date_message} ({formatted_date})"

force_download = False
if len(sys.argv) >= 6:
    force_download = sys.argv[5].lower() == "true"

recording_path = sub_path + '/'
os.makedirs(recording_path, exist_ok=True)

def get_access_token():
    token_req_payload = {'grant_type': 'client_credentials'}
    get_token = f"https://zoom.us/oauth/token?grant_type=account_credentials&account_id={account_id}"
    token_response = requests.post(get_token, data=token_req_payload, verify=False, allow_redirects=False, auth=(client_id, client_secret))
    if token_response.status_code == 200:
        access_token = json.loads(token_response.text)
        # print(access_token['access_token'])
        return access_token['access_token']
    return None

def get_zoom_recordings(webid):
    url = f'https://api.zoom.us/v2/past_meetings/{webid}/instances'
    headers = {'Authorization': 'Bearer ' + access_token}
    response = requests.get(url, headers=headers)
    try:
        data = json.loads(response.text)
    except Exception as e:
        print(f"[zoomd][ERROR] Invalid JSON for webinar_id {webid}: {response.text}")
        raise
    if 'meetings' not in data:
        print(f"[zoomd][ERROR] No 'meetings' key in response for webinar_id {webid}: {data}")
        return []
    recordings = data['meetings']
    all_recordings = []
    for recording in recordings:
        url = f'https://api.zoom.us/v2/meetings/{recording["uuid"]}/recordings'
        response2 = requests.get(url, headers=headers)
        try:
            all_recordings.append(json.loads(response2.text))
        except Exception as e:
            print(f"[zoomd][ERROR] Invalid JSON for meeting {recording['uuid']}: {response2.text}")
            raise
    # print(all_recordings)
    return all_recordings

print(f'{Fore.BLUE}Generating zoom webinar access token{Fore.RESET}')
final_output = os.path.join(recording_path, f"{formatted_date}.mp4")
if os.path.exists(final_output):
    if force_download:
        print(f"{Fore.YELLOW}Force enabled: Deleting existing merged video.{Fore.RESET}")
        os.remove(final_output)
    else:
        print(f"{Fore.GREEN}Zoom video already exists: {final_output}{Fore.RESET}")
        sys.exit(0)

access_token = get_access_token()
print(f"{Fore.BLUE}Finding {date_message} webinar recording...{Fore.RESET}")
recordings = get_zoom_recordings(webinar_id)

new_recordings = []
for recording in recordings:
    for recording_file in recording.get('recording_files', []):
        if recording_file['file_type'] == 'MP4':
            recording_file['recording_start'] = recording_file['recording_start']
            recording_file['pass_code'] = recording.get('password', '')
            new_recordings.append(recording_file)

today_parts = [
    rec for rec in new_recordings 
    if str(parser.parse(rec['recording_start']).strftime("%Y%m%d")) == formatted_date
]
today_parts = sorted(today_parts, key=lambda x: parser.parse(x['recording_start']))

if today_parts:
    print(f"{Fore.GREEN}Found {len(today_parts)} part(s) for {formatted_date}.{Fore.RESET}")
    temp_list_file = os.path.join(recording_path, "join_list.txt")
    part_files = []

    with open(temp_list_file, 'w') as f:
        for i, part in enumerate(today_parts):
            video_url = part['download_url'] + '?access_token=' + access_token
            part_name = f"{formatted_date}_part{i+1}.mp4"
            part_path = os.path.join(recording_path, part_name)

            if not os.path.exists(part_path):
                print(f"{Fore.BLUE}Downloading part {i+1}: {part_name}{Fore.RESET}")
                wget.download(video_url, out=part_path)
            else:
                print(f"{Fore.YELLOW}Skipping existing: {part_name}{Fore.RESET}")

            part_files.append(part_path)
            f.write(f"file '{os.path.abspath(part_path)}'\n")

    print(f"{Fore.BLUE}Merging parts into: {final_output}{Fore.RESET}")
    # ffmpeg_cmd = ["ffmpeg", "-y", "-loglevel", "error", "-f", "concat", "-safe", "0", "-i", temp_list_file, "-c", "copy", final_output]
    ffmpeg_cmd = [
        "ffmpeg", "-y", "-loglevel", "error", "-f", "concat", "-safe", "0",
        "-i", temp_list_file,
        "-vf", "scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2",
        "-c:v", "libx264", "-preset", "fast", "-crf", "23",
        "-c:a", "aac", "-b:a", "128k",
        final_output
    ]
    subprocess.run(ffmpeg_cmd)

    if os.path.exists(final_output):
        print(f"{Fore.GREEN}Merged video created: {final_output}{Fore.RESET}")
        for part_file in part_files:
            try:
                os.remove(part_file)
                print(f"{Fore.YELLOW}Deleted part: {os.path.basename(part_file)}{Fore.RESET}")
            except Exception as e:
                print(f"{Fore.RED}Could not delete {part_file}: {e}{Fore.RESET}")
    else:
        print(f"{Fore.RED}Merge failed!{Fore.RESET}")
else:
    print(f"{Fore.RED}No recordings found for date: {formatted_date}{Fore.RESET}")